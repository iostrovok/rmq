// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/iostrovok/rmq (interfaces: Queue)

// Package mmock is a generated GoMock package.
package mmock

import (
	gomock "github.com/golang/mock/gomock"
	rmq "github.com/iostrovok/rmq"
	reflect "reflect"
	time "time"
)

// MockQueue is a mock of Queue interface
type MockQueue struct {
	ctrl     *gomock.Controller
	recorder *MockQueueMockRecorder
}

// MockQueueMockRecorder is the mock recorder for MockQueue
type MockQueueMockRecorder struct {
	mock *MockQueue
}

// NewMockQueue creates a new mock instance
func NewMockQueue(ctrl *gomock.Controller) *MockQueue {
	mock := &MockQueue{ctrl: ctrl}
	mock.recorder = &MockQueueMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockQueue) EXPECT() *MockQueueMockRecorder {
	return m.recorder
}

// AddBatchConsumer mocks base method
func (m *MockQueue) AddBatchConsumer(arg0 string, arg1 int, arg2 rmq.BatchConsumer) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddBatchConsumer", arg0, arg1, arg2)
	ret0, _ := ret[0].(string)
	return ret0
}

// AddBatchConsumer indicates an expected call of AddBatchConsumer
func (mr *MockQueueMockRecorder) AddBatchConsumer(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddBatchConsumer", reflect.TypeOf((*MockQueue)(nil).AddBatchConsumer), arg0, arg1, arg2)
}

// AddBatchConsumerWithTimeout mocks base method
func (m *MockQueue) AddBatchConsumerWithTimeout(arg0 string, arg1 int, arg2 time.Duration, arg3 rmq.BatchConsumer) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddBatchConsumerWithTimeout", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(string)
	return ret0
}

// AddBatchConsumerWithTimeout indicates an expected call of AddBatchConsumerWithTimeout
func (mr *MockQueueMockRecorder) AddBatchConsumerWithTimeout(arg0, arg1, arg2, arg3 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddBatchConsumerWithTimeout", reflect.TypeOf((*MockQueue)(nil).AddBatchConsumerWithTimeout), arg0, arg1, arg2, arg3)
}

// AddConsumer mocks base method
func (m *MockQueue) AddConsumer(arg0 string, arg1 rmq.Consumer) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddConsumer", arg0, arg1)
	ret0, _ := ret[0].(string)
	return ret0
}

// AddConsumer indicates an expected call of AddConsumer
func (mr *MockQueueMockRecorder) AddConsumer(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddConsumer", reflect.TypeOf((*MockQueue)(nil).AddConsumer), arg0, arg1)
}

// AddConsumerFunc mocks base method
func (m *MockQueue) AddConsumerFunc(arg0 string, arg1 rmq.ConsumerFunc) string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddConsumerFunc", arg0, arg1)
	ret0, _ := ret[0].(string)
	return ret0
}

// AddConsumerFunc indicates an expected call of AddConsumerFunc
func (mr *MockQueueMockRecorder) AddConsumerFunc(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddConsumerFunc", reflect.TypeOf((*MockQueue)(nil).AddConsumerFunc), arg0, arg1)
}

// Close mocks base method
func (m *MockQueue) Close() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Close indicates an expected call of Close
func (mr *MockQueueMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockQueue)(nil).Close))
}

// Publish mocks base method
func (m *MockQueue) Publish(arg0 ...string) bool {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Publish", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Publish indicates an expected call of Publish
func (mr *MockQueueMockRecorder) Publish(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockQueue)(nil).Publish), arg0...)
}

// PublishBytes mocks base method
func (m *MockQueue) PublishBytes(arg0 ...[]byte) bool {
	m.ctrl.T.Helper()
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "PublishBytes", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// PublishBytes indicates an expected call of PublishBytes
func (mr *MockQueueMockRecorder) PublishBytes(arg0 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishBytes", reflect.TypeOf((*MockQueue)(nil).PublishBytes), arg0...)
}

// PurgeReady mocks base method
func (m *MockQueue) PurgeReady() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PurgeReady")
	ret0, _ := ret[0].(int)
	return ret0
}

// PurgeReady indicates an expected call of PurgeReady
func (mr *MockQueueMockRecorder) PurgeReady() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PurgeReady", reflect.TypeOf((*MockQueue)(nil).PurgeReady))
}

// PurgeRejected mocks base method
func (m *MockQueue) PurgeRejected() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PurgeRejected")
	ret0, _ := ret[0].(int)
	return ret0
}

// PurgeRejected indicates an expected call of PurgeRejected
func (mr *MockQueueMockRecorder) PurgeRejected() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PurgeRejected", reflect.TypeOf((*MockQueue)(nil).PurgeRejected))
}

// ReturnAllRejected mocks base method
func (m *MockQueue) ReturnAllRejected() int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReturnAllRejected")
	ret0, _ := ret[0].(int)
	return ret0
}

// ReturnAllRejected indicates an expected call of ReturnAllRejected
func (mr *MockQueueMockRecorder) ReturnAllRejected() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReturnAllRejected", reflect.TypeOf((*MockQueue)(nil).ReturnAllRejected))
}

// ReturnRejected mocks base method
func (m *MockQueue) ReturnRejected(arg0 int) int {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReturnRejected", arg0)
	ret0, _ := ret[0].(int)
	return ret0
}

// ReturnRejected indicates an expected call of ReturnRejected
func (mr *MockQueueMockRecorder) ReturnRejected(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReturnRejected", reflect.TypeOf((*MockQueue)(nil).ReturnRejected), arg0)
}

// SetPushQueue mocks base method
func (m *MockQueue) SetPushQueue(arg0 rmq.Queue) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetPushQueue", arg0)
}

// SetPushQueue indicates an expected call of SetPushQueue
func (mr *MockQueueMockRecorder) SetPushQueue(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetPushQueue", reflect.TypeOf((*MockQueue)(nil).SetPushQueue), arg0)
}

// StartConsuming mocks base method
func (m *MockQueue) StartConsuming(arg0 int, arg1 time.Duration) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StartConsuming", arg0, arg1)
	ret0, _ := ret[0].(bool)
	return ret0
}

// StartConsuming indicates an expected call of StartConsuming
func (mr *MockQueueMockRecorder) StartConsuming(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartConsuming", reflect.TypeOf((*MockQueue)(nil).StartConsuming), arg0, arg1)
}

// StopConsuming mocks base method
func (m *MockQueue) StopConsuming() <-chan struct{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "StopConsuming")
	ret0, _ := ret[0].(<-chan struct{})
	return ret0
}

// StopConsuming indicates an expected call of StopConsuming
func (mr *MockQueueMockRecorder) StopConsuming() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StopConsuming", reflect.TypeOf((*MockQueue)(nil).StopConsuming))
}
